###########################################
#			system.py	
# file contains class defs for 
# Unit:  reprsentation of proccessor 
#
# UnitList: a collection of Units
#
# Module:  reprsentation of memory
#	       in a network 
#
# Network: composed of a UnitList
#		   and a Module. Tracks
#		   information about
#		   the current state of 
#		   the network
###########################################

'''
A unit is nickname for a proccessor.
I just didnt want to type proccessor 
all the time because it is long
and easy to misspell.

wait_time:   the accumulated number of cycles a unit
			 has spent waiting to access a 
			 particular module. This value
			 is only relevant for determining
			 the priority scheme and NOT
			 for caclulating the average.

module:	     If a Unit waited for a particular memory,
			 module, module is set to the index
		 	 of that memory module. Otherwise
			 the value is set to None indicating
			 that the unit can be assigned to 
			 a new module on the next cycle
'''
class Unit():
	def __init__(self):
		self.wait_time = 0
		self.module_index = None
	'''
	Called whenever a units 
	request was denied by a module
	'''
	def increment_wait_time(self):
		self.wait_time += 1

	'''
	reset_wait_time and
	free_unit are called whenever
	a unit that was waiting connects 
	to the module it was waiting for
	'''
	def reset_wait_time(self):
		self.wait_time = 0

	def free_unit(self):
		self.module_index = None

	'''
	Binds the unit to the module at index i
	This only should happen if unit 
	was denied its request to module i
	'''
	def bind_unit(self,i):
		self.module_index = i

	'''
	returns true if the unit is waiting
	'''
	def is_waiting(self):
		return self.module_index != None

'''
A UnitList is a data structure that
stores a collection of units. It
reprsents the proccessors in a Network
The primary job of a  UnitList is to order
itself according to the units with
the lowest wait time

unit_list: a list storing N units
unit_count: number of units in network
'''
class UnitList():
	def __init__(self,N:int):
		self.unit_list = [Unit() for i in range(N)]
		self.unit_count = N

	'''
	this method makes it possible to iterate
	directly overy a UnitList
	'''
	def __iter__(self):
		return iter(self.unit_list)

	'''
	Reorders the WaitList so that modules with higher
	total wait time appear at the front of the 
	wait List. After each cycle this method
	is called
	'''	
	def update_priority(self):
		f = lambda unit : unit.wait_time
		self.unit_list.sort(key=f, reverse=True)
		
'''
A module object is a data structure
used to represent the memory of a Network.
A module is composed of what i call 'slots', 
or individual memory cells. 

module_count: number of modules in network
'''
class Module():
	def __init__(self,M):
		self.Module = [None for i in range(M)]
		self.slot_count = M

	'''
	returns true if the slot at index i is 
	currently available
	'''
	def is_free(self,i:int):
		return self.Module[i] == None

	'''
	Slot i becomes occupied by a unit 
	Called whenever a unit generates
	a request to a free module
	'''
	def occupy(self,i):
		self.Module[i] = 1

	'''
	resets the module so that each slot is 
	unnocupied. This method is called
	at the end of each cycle
	'''
	def free_slots(self):
		for i in range(self.slot_count):
			self.Module[i] = None

'''
A network is composed of 
a) modules 
b) units 
c) information about state of network

The primary role of a network object is
to do book keeping and manage its
memory and units. It delegates 
the tasks of tracking which
slots in the module are free
and ordering of units
to the Module & UnitList
objects resp.

It tracks the number of cycles (requests)
made in addition to computing the average
access time.

Initialization
N: is the number of units in the netowrk
M: is the number of memory modules available in the network

Attributes
UnitList:	A list of all the units in the
			network ordered first by
			units with high wait time
			and secondly by lowered
			indexed units

Module: the representation of memory in the network

total_wait:	at a given point during the simulation
			'total_wait' reflects the total
			amount of time spent waiting by 
			each unit up to the current cycle.
			Note that this is not the same as
			unit.wait_time which reflects the
			amount of time a unit has spent trying
			to access a particular module. 
			Put simply, any time a unit waits,
			this value is incremented

total_requests: is the number of hits/misses 
		generated by units Since each of the 
		k units generates a request every cycle
		in my simulation, this number is k*C
		where C > 0 and denotes number of cycles
'''
class Network():
	def __init__(self,N:int, M:int):
		self.UnitList = UnitList(N)
		self.Module = Module(M) 
		self.total_wait = 0
		self.total_requests = 0

	'''
	Any time a units request is denied
	this method is called
	'''
	def increment_total_wait(self):
		self.total_wait += 1

	'''
	This is only updated at the end of a cycle
	since at the end of a cycle, each of the N
	units will have generated a request
	and so we can simply increase the total
	number of requests by N
	'''
	def update_total_requests(self):
		self.total_requests += self.UnitList.unit_count
		
	'''
	At the end of each cycle this function
	gives the average access time. Note here
	That self.total_wait time already encapsulates
	what TA refers to as 'total still wait time'
	since total_wait time is incremented
	any time a unit waits.
	'''
	def average_access_time(self):
		return self.total_wait / float(self.total_requests)
